#!/bin/bash
 
echo
echo
echo ⣿⣿⣿⣿⣿⣿⣿⡇⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⡇⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⡇⢸⣿⣿⣿⣿⣿⣿⣿⣿⡟⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿ 
echo ⣿⣿⣿⣿⣿⣿⣿⡇⠀⣿⣿⣿⣿⣿⣿⣿⡿⢁⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⠀⢸⣿⣿⣿⡟⢸⡿⠁⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⢻⡇⢸⠃⡼⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠈⠇⣾⠀⠇⠀⢀⣿⠛⠛⠻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣯⠱⠀⠀⠏⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⢙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⡴⠉⠉⠉⠙⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠊⠉⠛⠛⢛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠀⢸⠀⠀⠀⣀⠤⠖⠒⠒⠒⠒⠶⠦⢤⠴⠖⠚⠋⠉⠉⠉⠉⠉⠉⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⣸⠁⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⢀⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⣤⠤⢤⣤⣀⣀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣠⣾⣥⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠞⠋⠁⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠰⠃⠀⠀⠀⠀⠀⠐⠲⠤⣀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⣰⡄⠀⠀⠀⠀⠀⠀⠀⣀⣤⡤⠤⣤⣄⣀⠈⠛⢶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠀⠀⢸⡏⠀⠀⠀⠀⠉⠈⠙⠢⠈⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠲⠢⢤⣀⡀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢻⡏⢀⠔⠀⠀⠀⢠⠀⠀⢸⡇⠀⠀⠀⠀⣀⡀⠀⠈⠙⠳⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠸⠞⡁⠀⠀⠀⢠⠇⠀⠀⢸⡇⠀⠀⠀⠀⠀⠈⠙⠳⢦⣤⣨⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣀⡴⠊⠀⠀⠀⠀⡞⠀⠀⠀⣼⡇⠀⠀⠀⠀⠛⠓⠦⢤⣀⡈⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠉⠀⠀⠀⠀⠀⣸⠧⠖⠀⠀⣿⡇⠀⠀⠀⠀⢤⢄⣀⠀⠉⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠊⠁⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠈⠙⠳⢦⣤⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⣀⣠⣤⣄⡀⠀⠀⠀⠀⣿⡁⠀⠀⠀⠀⠋⠑⠲⢤⣄⡀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⣀⣤⣶⠟⠋⠁⣠⠼⠛⣦⠀⠀⠀⢿⣄⣀⡀⠀⠀⠀⠀⠀⠀⠉⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠉⢀⡤⠖⠋⠀⠀⠀⠘⣧⠀⠀⠀⠉⠙⠛⠻⠿⠷⣶⣦⣄⡀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣦⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⠟⠛⠋⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⢤⡾⠃⠀⠀⠀⢀⣠⠴⠊⠀⠀⢸⣿⣿⣿⣿⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⡟⠁⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠉⠁⠀⠀⠁⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⠃⢠⠀⠀⠀⠀⠀⢀⣠⠟⠀⠀⠀⠀⠀⠀⠀⠠⡄⢶⠤⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣶⣿⣷⣾⣶⣦⣶⣿⣿⣶⣶⣶⡤⣤⣤⣀⣀⣀⡟⡸⠀⠀⠀⠀⠀⠀⢀⡴⠶⠶⣤⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⠞⠋⠀⠀⠀⠈⠉⠛⠻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⡠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠒⠒⠀⠀⠀⠀⣀⡀⠀⠀⠀⠈⠉⠛⠻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⢀⠀⠠⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⣶⣦⣤⣀⠀⠀⠀⠀⠉⠙⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⣿⠃⢠⠞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠦⠴⠒⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣶⣤⣄⣀⠀⠀⠀⠉⠙⠻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⠇⢠⣏⣀⣀⣀⣀⣀⠀⡀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢆⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣤⣀⠀⠀⠀⠉⠛⠿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⡟⠀⡜⠀⠀⠀⠉⠉⠉⠉⠁⠀⠀⠀⢀⡇⠀⠀⠀⠀⠀⢇⣀⣀⣀⡀⠀⢸⡄⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣦⣄⡀⠀⠀⠈⠙⠿⣿
echo ⣿⣿⣿⣿⣿⣿⠁⢰⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠃⠀⠀⠀⠀⠀⠈⠉⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣄⡀⠀⣘
echo ⣿⣿⣿⣿⣿⣿⠀⢸⣁⡀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⣾⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⡟⠀⣸⠉⠉⠉⠉⠉⠉⠙⠃⠀⠀⠀⢠⡟⠀⠀⠀⠀⠀⠀⠀⢸⣀⣀⣀⣀⣀⣀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⠀⠀⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⡟⠛⠛⠛⠛⠛⠛⠚⠁⠀⠀⢸⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣀⣀⣀⣀⣠⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo ⣿⣿⣿⣿⣿⣿⣿⡃⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⣼⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
echo

# Preparing to colour the output
RED='\033[0;31m'
BRED='\033[1;31m'
NC='\033[0m'
BLUE='\033[0;34m'
BBLUE='\033[1;34m'
GREEN='\033[0;32m'
BGREEN='\033[1;32m'
BYELLOW='\033[1;33m'

echo -e "${BYELLOW}WRITTEN BY: Yossef TSVI - STUDENT CODE: S19" 
echo -e "CLASS CODE: 7736.14     - LECTURER: Lior KAGAN${NC}"
echo
echo "WELCOME! THIS SCRIPT IS AN AUTOMATIC PENETRATION TESTER. IT WILL ALLOW YOU TO SCAN A LAN NETWORK YOU ARE CONNECTED TO, FIND LIVE HOSTS, SCAN EACH HOST FOR OPEN PORTS, RUNNING SERVICES AND POTENTIAL VULNERABILITIES. IT THEN WILL PERFORM BRUTE FORCE ATTACK ( IF POSSIBLE ) AND PRINT REPORTS FOR THE TARGETED NETWORK AND ITS IPs. ENJOY!"
sleep 5
echo

#Checking that the script user logged in  with administrator account using "id" command. If not we will ask him to run the script under administrator account and we will quit. This will prevent privileges error or complications.
idcheck=$(id | cut -d ' ' -f 1)

if [[ ! "$idcheck" == "uid=0(root)" ]]; then
	echo "YOU MUST RUN THIS SCRIPT UNDER AN ADMINISTRATOR ACCOUNT. QUITTING!"
	exit 1
else
	echo "YOU LOGGED IN WITH AN ADMINISTRATOR ACCOUNT. GOOD: WE CAN CONTINUE!"
fi
sleep 2
echo

#Checking that the user has the requiered programs to run this script, with "dpkg". If not, we will install them with "apt install" command: 
req_progs=(ipcalc arp-scan nmap hydra exploitdb)
	
	
	for prog in "${req_progs[@]}"; do
		check=$(dpkg -s "$prog" 2>/dev/null 2/dev/null | grep -Eo 'Status: install ok installed')
	
		if [[ ! "$check" =~ 'Status: install ok installed' ]]; then
			echo ""$prog" INSTALLATION REQUIRED!"
			echo
			echo "INSTALLING "$prog"..."
			apt install "$prog" -qq 2>/dev/null >/dev/null
			if [ $? -eq 0 ]; then
	       			echo ""$prog" SUCCESSFULLY INSTALLED."
			else
				echo "CANNOT INSTALL "$prog". QUITTING!"
				exit 1
			fi		
		fi
		sleep 3
	done
echo

#Creating a function to check the last command was performed with no problem:
function everything_ok() {
	if [ $? -eq 0 ]; then
		echo "WE CAN CONTINUE."
	else 
		echo "PROBLEM OCCURRED. QUITTING!"
		exit 1
	fi
}

#Creating variables for scan date and another to display the scan date into the directory where the final reports will be saved ( so the user can scan the same network multiple times without loosing the past findings ).
scan_date=$(date)
date_for_file=$(date +%d-%m-%Y_%H:%M:%S)

#Creating functions for grep to make the script easier to write:
function grep_ip_range() {
	grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}'
}

function grep_ip() {
	grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}'
}	

#Harvesting  lan network info using  "ip a", "ipcalc", and "ip route" and "arp-scan". Using grep and cut to gather the info we are interested in and putting them into all the variables for displaying general network info.  
ip_range=$(ip a show eth0 | grep_ip_range)
network_range=$(ipcalc $ip_range | grep Network | grep_ip_range)
host_min=$(ipcalc $ip_range | grep HostMin | grep_ip)
host_max=$(ipcalc $ip_range | grep HostMax | grep_ip)
my_ip=$(ip a show eth0 | grep_ip | grep -Ev '([0-9]{1,3}\.){3}255')
gateway=$(ip route | grep via | grep_ip | grep -Ev "$my_ip")
network_ip=$(echo $network_range | grep_ip)

#Creating a directory under /tmp/VULNER/ where all raw infos for this specific network will be stored, so if we want to scan other network the relevant info will be easier to locate:
echo "CHECKING IF /tmp/VULNER AND /tmp/VULNER/"$network_ip" EXIST AND CREATING THEM IF NOT."
[ -d /tmp/VULNER/"$network_ip" ] || mkdir -p /tmp/VULNER/"$network_ip"
everything_ok
echo

path_to_network=/tmp/VULNER/"$network_ip"
 
echo "REMEMBER THAT ALL THE RAW INFO GATHERED BY ALL SCANS FOR NETWORK "$network_range" WILL BE STORED UNDER THIS DIRECTORY: "$path_to_network""
sleep 2
echo
echo -e "${BRED}BE AWARE THAT ALL DATA STORED UNDER /tmp WILL BE DELETED AFTER YOUR NEXT REBOOT!${NC} (DON'T WORRY: YOU WILL SOON CHOOSE WHERE TO SAVE FINAL RESULTS REPORTS.) "
sleep 4
echo
echo -e "${BLUE}SCAN STARTING TIME:${NC}"
echo "$scan_date"
sleep 2
echo
echo -e "${BLUE}NETWORK INFO:${NC}"

#Creating functions to find Hosts up and select a target IP from a menu.
function find_hosts() {
        arp-scan $network_range  | grep_ip | grep -v "$my_ip"
}

function select_target() {	
	select tip in "${relevant_ips[@]}"; do
		 if [ -z $tip ]; then
			 echo "Invalid input!"
		 else
			 break
		 fi
	done
}

#Creating variable for all hosts up ( including user's ) and for hosts up without the user ( for scanning).
hosts_up=$(arp-scan $network_range | grep_ip)
live_ips_without_me=$(find_hosts)

echo -e "${BYELLOW}Target Network ID:${NC} $network_range"
echo -e "${BYELLOW}Network IPs Range: ${BGREEN}First Possible IP:${NC} $host_min ${BGREEN}  Last Possible IP:${NC} $host_max"
echo -e "${BYELLOW}Network Gateway:${NC} $gateway"
sleep 3
echo
echo -e "${BLUE}SCANNING FOR HOSTS:${NC}"
echo "$live_ips_without_me" > "$path_to_network"/relevant_ips.txt
path_to_relevant_ips="$path_to_network"/relevant_ips.txt 

echo -e "${BYELLOW}Hosts up:${NC}"
echo "$hosts_up"
sleep 3
echo
echo -e "${BYELLOW}Your IP:${NC}"
echo "$my_ip"
echo
echo -e "${BYELLOW}Network Gateway:${NC}"
echo "$gateway"
sleep 3
echo
echo -e "${BYELLOW}Relevant Target IPs:${NC}"
echo "$live_ips_without_me" 
sleep 3
echo
echo -e "SCANNING...PLEASE BE PATIENT: IT SHOULD TAKE A FEW MINUTES... MEANWHILE YOU CAN LOOK AT THE SAMURAI UP THERE :)..."
echo
readarray -t relevant_ips < <(echo "$live_ips_without_me")

#Creating function to display ports and services scan results: 
function grep_ports() {
	grep -Eo "[0-9]+/t"
}

function display_ports_servs() {
	cat "$path_to_network"/"$1"_OsVscan.nmap | grep -E '^([0-9]+/)' | awk '{print $1,$3,$4,$5,$6,$7,$8,$9,$10,$11}'
}

#Creating a "for" loop which, for each IP in the array "relevant_ips", that will perform an nmap scan for OS, Ports and Running Services, and searchsploit scans to find potential vulnerabilities.  Results will be checked whith if conditions and statements( ex.: is there any data? ) , and data will be redirected to files and variables for easier data processing and also for the final report. Meanwhile, the user will be abble to see the results on the terminal, in order to have an idea of the findings. The script will harvest the info we are interested in with "cat", "grep", "cut", "awk", "tr".
for ip in "${relevant_ips[@]}"; do
	echo
	#1. run an nmap -O -sV scan for Operating System info and for open tcp ports and their running services. With the flag -oA it will output 3 different kinds of result files for 1 scan (we will soon need the .nmap and .xml formats). sending the results to "grep" via a pipe to have just the ports lines and putting that into a variable. From that variable we will extract only the ports number and put it also into a variable.  
	result_ports_services=$(nmap -n -O -sV $ip -oA "$path_to_network"/"$ip"_OsVscan | grep_ports)
	path_to_OsVscan="$path_to_network"/"$ip"_OsVscan	
	opened_ports=$(echo $result_ports_services | grep_ports | cut -d'/' -f1)
	os=$(cat "$path_to_network"/"$ip"_OsVscan.nmap | grep "details")
	oskernel=$(cat "$path_to_OsVscan".nmap | grep Running | cut -d ' ' -f 2-3)
	
	cat "$path_to_OsVscan".nmap | grep -E "[0-9]+/" | grep -v initiated | awk '{print $4,$5,$6,$7}' | cut -d '(' -f1 > "$path_to_network"/"$ip"_services.txt
	path_to_services="$path_to_network"/"$ip"_services.txt

	readarray -t services < "$path_to_services"
	echo -e "${BGREEN}SCANNING IP $ip:${NC}"
	echo "File "$path_to_OsVscan".gnmap created." 
	echo "File "$path_to_OsVscan".nmap created."
	echo "File "$path_to_OsVscan".xml created."
       	echo
	echo -e "${BLUE}SCANNING FOR SERVICES, PORTS AND OPERATING SYSTEM:${NC}"
	echo -e "${BYELLOW}Open Ports:${NC}"	
	echo $opened_ports > "$path_to_network"/"$ip"_ports_scan.txt
	path_to_ports="$path_to_network"/"$ip"_ports_scan.txt

		if [ -z "$opened_ports" ]; then
			echo "NO PORTS INFO AVAILABLE FOR THIS IP." | tee "$path_to_ports"
			cat "$path_to_OsVscan".nmap | grep All | tee -a "$path_to_ports"
			echo "File "$path_to_ports" created."
		else
			echo "$opened_ports" | tr '\n' ' '
		fi	
	echo
	echo 
	echo -e "${BYELLOW}Running Services on the above Ports:${NC}"
	if [[ -z "${services[@]}" ]]||[[ "${services[@]}" =~ ^([^[:graph:]]+)$ ]]; then
			echo "NO INFO FOR THIS IP." | tee "$path_to_services"
			echo "File "$path_to_services" created."
		else
			display_ports_servs "$ip"
			echo "File "$path_to_services" created."
		fi
	echo
	echo
	echo -e "${BYELLOW}Operating System Info:${NC}"
		if [ -z "$oskernel" ]; then
			echo "NO INFO FOR THIS IP." | tee "$path_to_network"/"$ip"_osinfo.txt
			cat "$path_to_OsVscan".nmap | grep "Too many" | tee -a "$path_to_network"/"$ip"_osinfo.txt
			echo "File "$path_to_network"/"$ip"_osinfo.txt created."
 
		else
			echo "$oskernel" | tee "$path_to_network"/"$ip"_osinfo.txt
			echo "$os" | tee -a "$path_to_network"/"$ip"_osinfo.txt
			echo "File "$path_to_network"/"$ip"_osinfo.txt created."	
		fi
	echo
	echo
	#2. search for potential vulnerabilities of the Operating System with searchsploit.	
	echo -e "${BLUE}SCANNING FOR VULNERABILITIES:${NC}"
	echo "Scanning OS $oskernel for vulnerabilities..."
		if [ -z "$oskernel" ]; then
			echo "NO OS INFO: CANNOT CHECK FOR VULNERABILITIES." | tee "$path_to_network"/"$ip"_vuln_oscan.txt 
		else
			searchsploit "$oskernel" &>/dev/null > "$path_to_network"/"$ip"_vuln_oscan.txt
			echo "File "$path_to_network"/"$ip"_vuln_oscan.txt created."
			if [[ -z "$path_to_network"/"$ip"_vuln_oscan.txt ]]||[[ ! $(cat "$path_to_network"/"$ip"_vuln_oscan.txt) =~ ([/]+) ]]; then
				echo "NO VULNERABILITIES FOUND."
			else
				echo -e "${BRED}POTENTIAL VULNERABILITIES FOUND!${NC}"
			fi
		fi
	echo
	path_to_vuln_services="$path_to_network"/"$ip"_vuln_services_scan.txt 

	#3. search for potential vulnerabilities of the running services found with "searchsploit" ( using the nmap .xml format output).
	echo "Scanning Running Services for Vulnerabilities..."
		if [[ -z "${services[@]}" ]]||[[ "${services[@]}" =~ ^([^0-9A-Za-z]+)$ ]]; then
			echo "NO SERVICES INFO: CANNOT CHECK FOR SERVICES VULNERABILITIES." | tee "$path_to_vuln_services"
			echo "File "$path_to_network"/"$ip"_vuln_services_scan.txt created."
			 
		else
			searchsploit --nmap "$path_to_OsVscan".xml &>/dev/null > "$path_to_network"/"$ip"_vuln_services_scan.txt	
			echo "File "$path_to_vuln_services" created."	
				if [[ -z "$path_to_network"/"$ip"_vuln_services_scan.txt ]]; then
					echo "NO VUNERABILITIES FOR SERVICES."
						
	
				else 
					echo -e "${BRED}POTENTIAL VULNERABILITIES FOUND!${NC}"
						

				fi
		fi
echo
echo	
sleep 3
done
echo
echo -e "${BLUE}WEAK PASSWORDS SCAN:${NC}"
#Creating a function in order to check that the user input an existing option:

function y_n_inval_inp() {
	while [[ ! "$choice" =~ ^[yn]$ ]]; do
	read -p "INVALID INPUT: INPUT y (for yes) or n (for no)." choice
done
}

# Here the user will be given an option for performing a Weak Passwords Scan with hydra for the found Hosts up. After asking him wheither he wants to do such, and checking that his answer is valid with the above function, a "while" loop will enable the user to perform several scans for several ips without exiting the program and starting from the beginning. Using if conditions and statements we will first check that such a scan can be performed for the chosen ip. If not, the script will move to the next section: Final Report.

read -p "DO YOU WANT TO PERFORM A PASSWORDS SCAN?[y/n] " choice
y_n_inval_inp

while [[ "$choice" =~ ^[y]$ ]]; do
	echo
	echo 'Choose a target IP from below ( write the number of your choice - ex. 1 )'
	select_target "$live_ips_without_me"
	echo
	echo -e "${BYELLOW}CHOSEN TARGET IP:${NC} $tip"
	echo
		if [[ $(cat "$path_to_network"/"$tip"_services.txt) == "NO INFO FOR THIS IP." ]]; then
			echo "NO SERVICES INFO AVAILABLE. CANNOT PERFORM PASSWORDS SCAN."
		else	
#If such a scan can be performed for the chosen ip, the script will ask the user to enter a Users List, check if the file indeed exists	and store it in a variable which we'll need for the hydra search.		
			read -p "Please enter a full path to users list: " path_to_user_lst
			while [ -z "$path_to_user_lst" ]; do
				read -p  "INVALID INPUT! PLEASE ENTER A FULL VALID PATH TO A USERS LIST: " path_to_user_lst
			done
			while [[ ! -f "$path_to_user_lst" ]]; do
				read -p "INVALID PATH! PLEASE ENTER A FULL VALID PATH TO A USER LIST: " path_to_user_lst
			done
			echo
			echo -e "${BYELLOW}Path to users list:${NC}"$path_to_user_lst"."

#Now the script will ask the user if he wants to use an existing Passwords List or generate one. Like all other inputs, the answer will be checked with if conditions and statements ( in case of invalid input he will be trapped into a "while" loop again ).

			echo "Do you want to use an existing passwords list or do you want to generate a passwords list? ( write the number of your choice - ex. 1 )"
			select pas_lst_choice in "use an existing passwords list" "generate a passwords list"; do
#if he chose to use an existing PL, the script will ask him the path to the Passwords List file, and check that file exists. If not: trapped into a "while" loop.

				if [[ "$pas_lst_choice" == "use an existing passwords list" ]]; then
					echo -e "${BYELLOW}You chose to "$pas_lst_choice".${NC}"
					read -p "Please enter the full path to the existing passwords list: " path_to_pas_lst
					while [ -z "$path_to_pas_lst" ]; do
						read -p "INVALID INPUT! PLEASE ENTER A FULL VALID PATH TO A PASSWORDS LIST: " path_to_pas_lst
					done
					while [ ! -f "$path_to_pas_lst" ]; do
						read -p "INVALID PATH! PLEASE ENTER A FULL VALID PATH TO A PASSWORDS LIST: " path_to_pas_lst	
					done
					echo
					echo -e "${BYELLOW}Path to passwords list:${NC}"$path_to_pas_lst"."
					break
#If the user chooses to generate a passwords list, the script will ask him the number of characters one password should contain, and how many passwords the list should contain. His answer will be checked with if conditions and statements and if he enters other characters than numbers he will be trapped into a "while" loop.
				elif [[ "$pas_lst_choice" == "generate a passwords list" ]]; then
					echo -e "${BYELLOW}You chose to "$pas_lst_choice".${NC}"
					read -p "Enter the number of characters the passwords should contain ( ex. 8 ): " length
					
					while [[ ! "$length" =~ ^([0-9]+)$ ]]; do
						read -p "You should input a number! Input: " length
					done
					echo
					read -p "Enter the number of passwords the list should contain ( ex. 10 ): " kama
					while [[ ! "$kama" =~ ^([0-9]+)$ ]]; do
						read -p "You should input a number! Input: " kama
					done
#After the script get the lenght and numbers parameters, it will generate the Passwords List with /dev/random.
					tr -cd '[:graph:]' < /dev/random | fold -w"$length" | head -"$kama" > "$path_to_network"/"$tip"_passwad.lst

					path_to_pas_lst="$path_to_network"/"$tip"_passwad.lst
					echo -e "${BYELLOW}Path to generated passwords list:${NC}"$path_to_pas_lst"."
					break
				else
					echo "Invalid input!"
				fi
			done	
			#Now we have a User List, a Password List, but we need to find a hydra supported service and if indeed found we need to know on which port it is running ( not always running on the default port ). Using the nmap scan we performed earlier, we will cut the running services and store them in an array. Also we will create a a file containing the hydra supported services using "sed" to make a file readable by a while read loop.

			echo
			path_to_tip_OsVscan="$path_to_network"/"$tip"_OsVscan 
			tip_result_ports_services=$(cat "$path_to_tip_OsVscan".nmap | grep -E "[0-9]+/")
			opened_ports=$(echo "$tip_result_ports_services" | grep -Eo "[0-9]+/" | cut -d'/' -f1)

			readarray -t protocols < <(cat "$path_to_tip_OsVscan".nmap | grep -E "[0-9]+/" | awk '{print $3}')  
			echo "adam6500|asterisk|cisco|cisco-enable|cobaltstrike|cvs|firebird|ftp|ftps|https|http|http-head|http-get|http-post|http-get-form|http-post-form|http-proxy|http-proxy-urlenum|icq|imap|irc|ldap2|ldap3|memcached|mongodb|mssql|mysql|nntp|oracle-listener|oracle-sid|pcanywhere|pcnfs|pop3|postgres|radmin2|rdp|redis|rexec|rlogin|rpcap|rsh|rtsp|s7-300|sip|smb|smtp|smtp-enum|snmp|socks5|ssh|sshkey|svn|teamspeak|telnet|vmauthd|vnc|xmpp" | sed 's/|/\n/g' > "$path_to_network"/hydra_sup_services.lst
			echo
#Then we will run on the target ip services (in an array) with a "for" loop that will check if there is a service that is a hydra supported service with a while read loop that will continue checking untill a service is found or untill it finishes reading. if there are no ports or no readable findings, the script will let us know.
			for prot in ${protocols[@]}; do 
				while read hprot; do
					if [[ "$prot" != "$hprot" ]]; then 
						continue
					elif [[ $(echo "$prot") =~ ^[^[:graph:]]$ ]]; then
						echo "DIDN'T FIND ANY LOGIN SERVICE TO SCAN FOR PASSWORDS." | tee "$path_to_network"/"$tip"_passwords && break 2
					else 
						break 2			
					fi
				done < "$path_to_network"/hydra_sup_services.lst 
			done
#The script will check if the same service is running on two differents ports, and will harvest the first one.			
			if [[ $(echo "$prot") =~ ^([a-zA-Z0-9]+)$ ]]; then
				readarray -t port_BF < <(cat "$path_to_network"/"$tip"_OsVscan.nmap |  grep "$prot" | grep_ports | cut -d'/' -f1)
					if [ ${#port_BF[@]} -gt 1 ]; then 
						port_BF=$(echo "${port_BF[0]}")
					fi	
				echo -e "${BYELLOW}For this device the first found Login Service is${NC} "$prot" ${BYELLOW}running on port${NC} "$port_BF"."
			fi
		echo

function scan_ok() {
	if [ ! $? -eq 0 ]; then
		echo "Problem occured: search aborted." | tee "$path_to_network"/"$tip"_passwords
 
	else
		echo "Search completed."
	fi
}
	

# Now we have Users List, Passwords List, Running Service name and Port, the script will first run hydra for a quick easy passwords search (nsr). With grep, it will harvest passwords (if found) and tee them to file.  

			echo "Performing NSR -Null, Same, Reverse- Passwords Scan for "$prot" login service on port "$port_BF"..."

			hydra -L "$path_to_user_lst" -e nsr -t 4 -w 6 "$tip" "$prot" -s "$port_BF" 2>/dev/null | grep host | tee "$path_to_network"/"$tip"_passwords
			scan_ok
			echo "File "$path_to_network"/"$tip"_passwords created."
	
#We will, now, run hydra for a deeper passwords search using our passwords list (generated or existing). Here too, grep will help us to harvest passwords, and tee -a them to file.
			echo
			echo "Performing  Passwords Scan for "$prot" login service on port "$port_BF" with a passwords list..."
			hydra -L "$path_to_user_lst" -t 4 -w 6 -P "$path_to_pas_lst" "$tip" "$prot" -s "$port_BF" 2>/dev/null | grep 'host' | tee -a "$path_to_network"/"$tip"_passwords
			scan_ok
			fi
	echo
#Giving option to scan multiple IPs without running the script from the beginning.
	read -p "Do you want to perform a Passwords Scan for another IP?[y/n] " choice
		y_n_inval_inp
done
echo
#Now the user can choose where to save the Final Reports.
read -p "INPUT THE FULL PATH TO THE DIRECTORY YOU WANT THE FINAL REPORT TO BE SAVED UNDER: " work_dir
	while [ ! -d "$work_dir" ]; do
		read -p "INVALID PATH! PLEASE INPUT A VALID FULL PATH TO A DIRECTORY: " work_dir
	done
[ -d "$work_dir"/VULNER/"$date_for_file"_"$network_ip" ] || mkdir -p "$work_dir"/VULNER/"$date_for_file"_"$network_ip"

path_to_final_report="$work_dir"/VULNER/"$date_for_file"_"$network_ip"/general_final_report.txt

#Creating a function that tee the final report to file:
 
function tee_to_file() {
	tee -a "$path_to_final_report"
}

echo
#Issuing the Network General Final Report.
echo -e "${BYELLOW}FINAL REPORT FOR NETWORK "$network_range" CREATED. PATH:${NC}"$path_to_final_report" "
sleep 3
echo
echo -e "${BBLUE}FINAL REPORT FOR NETWORK "$network_range":${NC}" | tee_to_file

device_num=$(arp-scan $network_range | grep_ip | wc -l)
echo -e "${BBLUE}GENERAL: ${NC}" | tee_to_file
echo -e "${BYELLOW}Scan Started at:${NC} $scan_date" | tee_to_file
echo | tee_to_file
echo -e "${BYELLOW}NETWORK INFO:${NC}" | tee_to_file
echo -e "${BYELLOW}Network ID:${NC} $network_range" | tee_to_file
echo -e "${BYELLOW}Network Range:${NC} ${BGREEN}First  Possible IP:${NC} $host_min ${BGREEN} Last Possible IP:${NC} $host_max" | tee_to_file
echo | tee_to_file
echo -e "${BYELLOW}Number of Devices Connected to this Network:${NC} $device_num" | tee_to_file
echo "( including your device and the gateway device )" | tee_to_file
echo | tee_to_file
echo -e "${BYELLOW}Hosts up:${NC} " | tee_to_file
echo "$hosts_up" | tee_to_file
echo | tee_to_file
echo -e "${BYELLOW}Network Gateway:${NC} $gateway" | tee_to_file
echo | tee_to_file
echo -e "${BYELLOW}Your IP:${NC} $my_ip" | tee_to_file
echo | tee_to_file
echo | tee_to_file
#Asking the user if he wants to display info about one of the IPs. Putting his answer in a while loop, the script gives him the option of checking every IP he wants to check.
read -p "DO YOU WANT TO ISSUE A REPORT FOR A SPECIFIC IP?[y/n]" choice
y_n_inval_inp
while [[ "$choice" =~ [y] ]]; do
	echo "Enter an IP from below to display its report: "
	select_target $live_ips_whithout_me
	path_to_final_report="$work_dir"/VULNER/"$date_for_file"_"$network_ip"/"$tip"_final_report.txt
	echo
	echo -e "${BYELLOW}FINAL REPORT FOR "$tip" CREATED. PATH:${NC} "$path_to_final_report""
	sleep 3
	echo | tee_to_file
	echo -e "${BBLUE}FINAL REPORT FOR IP "$tip":${NC}" | tee_to_file
		if [[ "$tip" == "$gateway" ]]; then
			echo "This the network gateway." | tee_to_file
		echo | tee_to_file
		fi       
	echo -e "${BGREEN}OPERATING SYSTEM INFO:${NC} " | tee_to_file
	cat "$path_to_network"/"$tip"_osinfo.txt | tee_to_file
	sleep 1
	echo | tee_to_file
	echo -e "${BGREEN}OPEN PORTS AND RUNNING SERVICES:${NC}" | tee_to_file
		if [[ $(cat "$path_to_network"/"$tip"_ports_scan.txt) =~ "NO PORTS INFO AVAILABLE FOR THIS IP." ]]; then
			cat "$path_to_network"/"$tip"_ports_scan.txt | tee_to_file
		else
		display_ports_servs "$tip" | tee_to_file
		fi
	sleep 2
	echo | tee_to_file
	echo -e "${BGREEN}VULNERABILIES SCAN RESULTS:${NC}" | tee_to_file
	echo -e "${BYELLOW}OPERATING SYSTEM:${NC}" | tee_to_file
	echo | tee_to_file
	cat "$path_to_network"/"$tip"_vuln_oscan.txt | tee_to_file
	echo | tee_to_file
	sleep 4
	echo | tee_to_file
	echo -e "${BYELLOW}SERVICES:${NC}" | tee_to_file
	echo | tee_to_file
	cat "$path_to_network"/"$tip"_vuln_services_scan.txt | tee_to_file
	echo | tee_to_file
	echo -e "${BGREEN}PASSWORDS:${NC}" | tee_to_file
		if [ ! -f "$path_to_network"/"$tip"_passwords ]; then
			echo "NO INFO: PASSWORDS SCAN WASN'T PERFORMED FOR THIS IP." | tee_to_file 
		elif [[ $(cat "$path_to_network"/"$tip"_passwords) =~ ^([^[:graph:]]*)$ ]]; then
       			echo "NO PASSWORDS FOUND." | tee_to_file	
		else	
			cat "$path_to_network"/"$tip"_passwords | tee_to_file
		fi

	echo | tee_to_file
	read -p "DO YOU WANT TO ISSUE A REPORT FOR ANOTHER IP?[y/n]" choice
	y_n_inval_inp
done
echo
echo -e "${BYELLOW}CREDITS:${NC}"
echo "JOHN BRYCE - LIOR'S LESSONS"
echo "https://emojicombos.com/samurai-ascii-art"
echo "https://codeahoy.com/learn/introtobash/ch17/"
echo "https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux"
echo "https://www.gnu.org/software/grep/manual/html_node/Character-Classes-and-Bracket-Expressions.html"
echo "https://www.kali.org/tools/hydra/"
echo "https://www.exploit-db.com/searchsploit"
echo "https://www.baeldung.com/linux/shell-script-simple-select-menu"
echo "https://unix.stackexchange.com/questions/200381/how-can-i-break-out-of-a-while-loop-from-within-a-nested-case-statement"
echo
echo
echo -e "${BYELLOW}THANK YOU FOR USING THIS SCRIPT!${NC}"
exit 0
